
============================================================
ECJ compiles reincarnation.decompiler.flow.SwitchExpressionTest$13
============================================================
Original Code
============================================================
@Debuggable
    void tryCatch() {
        verify(new TestCode.IntParam() {

            @Override
            public int run(@Param(from = 0, to = 5) int param) {
                return switch (param) {
                case 0, 1, 2 -> {
                    try {
                        param = MaybeThrow.error(param);
                    } catch (Error e) {
                        param = param + 1;
                    }
                    yield param;
                }
                default -> param;
                };
            }
        });
    }
============================================================
Decompiled Code
============================================================
01    package reincarnation.decompiler.flow;
02    
03    import reincarnation.CodeVerifier;
04    import reincarnation.TestCode.IntParam;
05    import reincarnation.TestCode.Param;
06    import reincarnation.decompiler.flow.MaybeThrow;
07    import reincarnation.decompiler.flow.SwitchExpressionTest;
08    
09    class SwitchExpressionTest extends CodeVerifier {
10    
11        class SwitchExpressionTest$13 implements IntParam {
12            final SwitchExpressionTest this$0;
13    
14            SwitchExpressionTest$13(SwitchExpressionTest arg0) {
15                this.this$0 = arg0;
16            }
17    
18            public int run(@Param(to = 5) int param) {
19                return switch (param) {
20                    case 0, 1, 2 -> {
21                        try {
22                            param = MaybeThrow.error(param);
23                        } catch(Error e) {
24                            ++param;
25                        }
26                        yield param;
27                    }
28                    default -> param;
29                };
30            }
31        }
32    }
============================================================
Decompiling Log
============================================================
//----------------------------- SwitchExpressionTest#tryCatch (SwitchExpressionTest.java:241) -----------------------------//
[38;5;21mMethod tryCatch()[0m (SwitchExpressionTest.java:242)
0	in[]	out[]	dom[]	doms[]	side[ ,1]	dest[T]	code: this.this$0 = arg0 [Assign#SwitchExpressionTest] java.lang.Object() [ConstructorCall] return null [Return - null]
1	in[]	out[]	dom[]	doms[]	side[0, ]	dest[]	code: 

Delete tail empty return (show full nodes)
[38;5;9m0	in[]	out[]	dom[]	doms[]	side[ , ]	dest[T]	code: this.this$0 = arg0 [Assign#SwitchExpressionTest] java.lang.Object() [ConstructorCall] return null [Return - null]
[0m
[38;5;78m0	in[]	out[]	dom[]	doms[]	side[ , ]	dest[T]	code: this.this$0 = arg0 [Assign#SwitchExpressionTest] java.lang.Object() [ConstructorCall]
[0m

Merge 0 0   []  []
0	in[]	out[]	dom[]	doms[]	side[ , ]	dest[T]	code: this.this$0 = arg0 [Assign#SwitchExpressionTest] java.lang.Object() [ConstructorCall]

//----------------------------- SwitchExpressionTest#tryCatch (SwitchExpressionTest.java:245) -----------------------------//
[38;5;21mMethod tryCatch()[0m (SwitchExpressionTest.java:246)
3	in[]	out[4,0]	dom[]	doms[]	side[ ,0]	dest[0]		try:   	code: switch-expression (arg0) [Switch]
0	in[3]	out[1]		dom[3]	doms[]	side[3,1]	dest[1]		try: s	code: arg0 = MaybeThrow.error(arg0) [Assign#int]
1	in[0]	out[5]		dom[0]	doms[]	side[0,2]	dest[5]		try: e	code: 
2	in[]	out[6]		dom[]	doms[]	side[1,6]	dest[6]		try: c	code: 
6	in[2]	out[5]		dom[2]	doms[]	side[2,5]	dest[5]		try:   	code: ++arg0 [Unary#int]
5	in[1,6]	out[7]		dom[]	doms[]	side[6,7]	dest[7]		try:   	code: local2 = arg0 [Assign#int]
7	in[5]	out[8]		dom[5]	doms[]	side[5,8]	dest[8]		try:   	code: local2 [LocalVariable#int]
8	in[7]	out[9]		dom[7]	doms[]	side[7,4]	dest[9]		try:   	code: 
4	in[3]	out[10]		dom[3]	doms[]	side[8,10]	dest[10]	try:   	code: local2 = arg0 [Assign#int]
10	in[4]	out[9]		dom[4]	doms[]	side[4,9]	dest[9]		try:   	code: local2 [LocalVariable#int]

Analyze switch [Range 3 - 10] (show full nodes)
[38;5;9m3	in[]	out[4,0]	dom[]	doms[0,4]	side[ ,0]	dest[0]		try:   	code: switch-expression (arg0) [Switch]
0	in[3]	out[1]		dom[3]	doms[1,2,5]	side[3,1]	dest[1]		try: s	code: arg0 = MaybeThrow.error(arg0) [Assign#int]
1	in[0]	out[5]		dom[0]	doms[]		side[0,2]	dest[5]		try: e	code: 
2	in[]	out[6]		dom[]	doms[6]		side[1,6]	dest[6]		try: c	code: 
6	in[2]	out[5]		dom[2]	doms[]		side[2,5]	dest[5]		try:   	code: ++arg0 [Unary#int]
5	in[1,6]	out[7]		dom[]	doms[7]		side[6,7]	dest[7]		try:   	code: local2 = arg0 [Assign#int]
7	in[5]	out[8]		dom[5]	doms[8]		side[5,8]	dest[8]		try:   	code: local2 [LocalVariable#int]
8	in[7]	out[9]		dom[7]	doms[]		side[7,4]	dest[9]		try:   	code: 
4	in[3]	out[10]		dom[3]	doms[10]	side[8,10]	dest[10]	try:   	code: local2 = arg0 [Assign#int]
10	in[4]	out[9]		dom[4]	doms[]		side[4,9]	dest[9]		try:   	code: local2 [LocalVariable#int]
[0m
[38;5;78m3	in[]	out[4,0]	dom[]	doms[0,4]	side[ ,0]	dest[0]		try:   	code: switch-expression (arg0) [Switch#int]
0	in[3]	out[1]		dom[3]	doms[1,2,5]	side[3,1]	dest[1]		try: s	code: arg0 = MaybeThrow.error(arg0) [Assign#int]
1	in[0]	out[5]		dom[0]	doms[]		side[0,2]	dest[5]		try: e	code: 
2	in[]	out[6]		dom[]	doms[6]		side[1,6]	dest[6]		try: c	code: 
6	in[2]	out[5]		dom[2]	doms[]		side[2,5]	dest[5]		try:   	code: ++arg0 [Unary#int]
5	in[1,6]	out[7]		dom[]	doms[7]		side[6,7]	dest[7]		try:   	code: local2 = arg0 [Assign#int]
7	in[5]	out[8]		dom[5]	doms[8]		side[5,8]	dest[8]		try:   	code: yield local2 [Yield#int - local2]
8	in[7]	out[]		dom[7]	doms[]		side[7,4]	dest[9]		try:   	code: 
4	in[3]	out[10]		dom[3]	doms[10]	side[8,10]	dest[10]	try:   	code: local2 = arg0 [Assign#int]
10	in[4]	out[]		dom[4]	doms[]		side[4,9]	dest[9]		try:   	code: yield local2 [Yield#int - local2]
[0m

Analyze try-catch-finally (show full nodes)
[38;5;9m3	in[]	out[4,0]	dom[]	doms[0,4]	side[ ,0]	dest[0]		try:   	code: switch-expression (arg0) [Switch#int]
0	in[3]	out[1]		dom[3]	doms[1,2,5]	side[3,1]	dest[1]		try: s	code: arg0 = MaybeThrow.error(arg0) [Assign#int]
1	in[0]	out[5]		dom[0]	doms[]		side[0,2]	dest[5]		try: e	code: 
2	in[]	out[6]		dom[]	doms[6]		side[1,6]	dest[6]		try: c	code: 
6	in[2]	out[5]		dom[2]	doms[]		side[2,5]	dest[5]		try:   	code: ++arg0 [Unary#int]
5	in[1,6]	out[7]		dom[]	doms[7]		side[6,7]	dest[7]		try:   	code: local2 = arg0 [Assign#int]
7	in[5]	out[8]		dom[5]	doms[8]		side[5,8]	dest[8]		try:   	code: yield local2 [Yield#int - local2]
8	in[7]	out[]		dom[7]	doms[]		side[7,4]	dest[9]		try:   	code: 
4	in[3]	out[10]		dom[3]	doms[10]	side[8,10]	dest[10]	try:   	code: local2 = arg0 [Assign#int]
10	in[4]	out[]		dom[4]	doms[]		side[4,9]	dest[9]		try:   	code: yield local2 [Yield#int - local2]
[0m
[38;5;78m3	in[]	out[4,0]	dom[]	doms[0,4]	side[ ,0]	dest[0]		try:   	code: switch-expression (arg0) [Switch#int]
0	in[3]	out[1]		dom[3]	doms[1,2,5]	side[3,1]	dest[1]		try: s	code: arg0 = MaybeThrow.error(arg0) [Assign#int]
1	in[0]	out[5]		dom[0]	doms[]		side[0,2]	dest[5]		try: e	code: 
2	in[]	out[6]		dom[]	doms[6]		side[1,6]	dest[6]		try: c	code: 
6	in[2]	out[5]		dom[2]	doms[]		side[2,5]	dest[5]		try:   	code: ++arg0 [Unary#int]
5	in[1,6]	out[7]		dom[]	doms[7]		side[6,7]	dest[7]		try: x	code: local2 = arg0 [Assign#int]
7	in[5]	out[8]		dom[5]	doms[8]		side[5,8]	dest[8]		try:   	code: yield local2 [Yield#int - local2]
8	in[7]	out[]		dom[7]	doms[]		side[7,4]	dest[9]		try:   	code: 
4	in[3]	out[10]		dom[3]	doms[10]	side[8,10]	dest[10]	try:   	code: local2 = arg0 [Assign#int]
10	in[4]	out[]		dom[4]	doms[]		side[4,9]	dest[9]		try:   	code: yield local2 [Yield#int - local2]
[0m

Merge 0 3   []  [4, 0]
Merge 0 0   [1]  [1]
Merge 1 0
Merge 0 1   []  [5]
Merge 0 2   [6]  [6]
Merge 1 2
Merge 0 6   []  [5]
Merge 0 5   [7]  [7]
Merge 1 5
Merge 2
Merge 3
Merge 0 7   []  []
Merge 0 8   []  []
Merge 0 4   [10]  [10]
Merge 1 4
Merge 2
Merge 3
Merge 0 10   []  []
Merge immediate return (show full nodes)
[38;5;9m3	in[]	out[4,0]	dom[]	doms[0,4]	side[ ,0]	dest[0]		try:   	code: switch-expression (arg0) [Switch#int]
0	in[3]	out[1]		dom[3]	doms[1,2,5]	side[3,1]	dest[1]		try: s	code: arg0 = MaybeThrow.error(arg0) [Assign#int]
1	in[0]	out[5]		dom[0]	doms[]		side[0,2]	dest[5]		try: e	code: 
2	in[]	out[6]		dom[]	doms[6]		side[1,6]	dest[6]		try: c	code: 
6	in[2]	out[5]		dom[2]	doms[]		side[2,5]	dest[5]		try:   	code: ++arg0 [Unary#int]
5	in[1,6]	out[7]		dom[]	doms[7]		side[6,7]	dest[7]		try: x	code: local2 = arg0 [Assign#int]
7	in[5]	out[8]		dom[5]	doms[8]		side[5,8]	dest[8]		try:   	code: yield local2 [Yield#int - local2]
8	in[7]	out[]		dom[7]	doms[]		side[7,4]	dest[9]		try:   	code: 
4	in[3]	out[10]		dom[3]	doms[10]	side[8,10]	dest[10]	try:   	code: local2 = arg0 [Assign#int]
10	in[4]	out[]		dom[4]	doms[]		side[4,9]	dest[9]		try:   	code: yield local2 [Yield#int - local2]
[0m
[38;5;78m3	in[]	out[4,0]	dom[]	doms[0,4]	side[ ,0]	dest[0]	try:   	code: switch-expression (arg0) [Switch#int]
0	in[3]	out[1]		dom[3]	doms[1,2,5]	side[3,1]	dest[1]	try: s	code: arg0 = MaybeThrow.error(arg0) [Assign#int]
1	in[0]	out[5]		dom[0]	doms[]		side[0,2]	dest[5]	try: e	code: 
2	in[]	out[6]		dom[]	doms[6]		side[1,6]	dest[6]	try: c	code: 
6	in[2]	out[5]		dom[2]	doms[]		side[2,5]	dest[5]	try:   	code: ++arg0 [Unary#int]
5	in[1,6]	out[8]		dom[]	doms[7]		side[6,8]	dest[8]	try: x	code: yield arg0 [Yield#int - arg0]
7	in[]	out[]		dom[]	doms[8]		side[5,8]	dest[8]	try:   	code: 
8	in[5]	out[]		dom[5]	doms[]		side[5,4]	dest[9]	try:   	code: 
4	in[3]	out[]		dom[3]	doms[10]	side[8,9]	dest[9]	try:   	code: yield arg0 [Yield#int - arg0]
10	in[]	out[]		dom[]	doms[]		side[4,9]	dest[9]	try:   	code: 
[0m

3	in[]	out[4,0]	dom[]	doms[0,4]	side[ ,0]	dest[0]	try:   	code: switch-expression (arg0) [Switch#int]
0	in[3]	out[1]		dom[3]	doms[1,2,5]	side[3,1]	dest[1]	try: s	code: arg0 = MaybeThrow.error(arg0) [Assign#int]
1	in[0]	out[5]		dom[0]	doms[]		side[0,2]	dest[5]	try: e	code: 
2	in[]	out[6]		dom[]	doms[6]		side[1,6]	dest[6]	try: c	code: 
6	in[2]	out[5]		dom[2]	doms[]		side[2,5]	dest[5]	try:   	code: ++arg0 [Unary#int]
5	in[1,6]	out[8]		dom[]	doms[7]		side[6,8]	dest[8]	try: x	code: yield arg0 [Yield#int - arg0]
7	in[]	out[]		dom[]	doms[8]		side[5,8]	dest[8]	try:   	code: 
8	in[5]	out[]		dom[5]	doms[]		side[5,4]	dest[9]	try:   	code: 
4	in[3]	out[]		dom[3]	doms[10]	side[8,9]	dest[9]	try:   	code: yield arg0 [Yield#int - arg0]
10	in[]	out[]		dom[]	doms[]		side[4,9]	dest[9]	try:   	code: 

Transform switch expression [Range 3 - 10] (show full nodes)
[38;5;9m3	in[]		out[4,0]	dom[]	doms[]	side[ ,0]	dest[0]		try:   	code: switch (arg0) [Switch]
0	in[3]		out[1]		dom[3]	doms[]	side[3,1]	dest[1]		try: s	code: arg0 = MaybeThrow.error(arg0) [Assign#int]
1	in[0]		out[5]		dom[0]	doms[]	side[0,2]	dest[5]		try: e	code: 
2	in[]		out[6]		dom[]	doms[]	side[1,6]	dest[6]		try: c	code: 
6	in[2]		out[5]		dom[2]	doms[]	side[2,5]	dest[5]		try:   	code: ++arg0 [Unary#int]
5	in[1,6]		out[7]		dom[]	doms[]	side[6,7]	dest[7]		try:   	code: local2 = arg0 [Assign#int]
7	in[5]		out[8]		dom[5]	doms[]	side[5,8]	dest[8]		try:   	code: local2 [LocalVariable#int]
8	in[7]		out[9]		dom[7]	doms[]	side[7,4]	dest[9]		try:   	code: 
4	in[3]		out[10]		dom[3]	doms[]	side[8,10]	dest[10]	try:   	code: local2 = arg0 [Assign#int]
10	in[4]		out[9]		dom[4]	doms[]	side[4,9]	dest[9]		try:   	code: local2 [LocalVariable#int]
9	in[8,10]	out[]		dom[]	doms[]	side[10, ]	dest[]		try:   	code: 
[0m
[38;5;78m3	in[]	out[9]	dom[]	doms[]	side[ ,9]	dest[0]	code: switch-expression (arg0) [Switch#int]
9	in[3]	out[]	dom[3]	doms[]	side[3, ]	dest[]	code: 
[0m

[38;5;21mMethod tryCatch()[0m (SwitchExpressionTest.java:246)
3	in[]	out[9]	dom[]	doms[]	side[ ,9]	dest[0]	code: 
9	in[3]	out[]	dom[3]	doms[]	side[3,11]	dest[T]	code: return switch-expression (param) [Return#int - Switch#int]
11	in[]	out[]	dom[]	doms[]	side[9, ]	dest[]	code: 

Merge 0 9   []  []
9	in[]	out[]	dom[]	doms[]	side[ , ]	dest[T]	code: return switch-expression (param) [Return#int - Switch#int]


============================================================


============================================================
Javac compiles reincarnation.decompiler.flow.SwitchExpressionTest$13
============================================================
/reincarnation/decompiler/flow/SwitchExpressionTest.java:27: ƒGƒ‰[: '.class'‚ª‚ ‚è‚Ü‚¹‚ñ
                default -> int local2 = paramlocal2;
                               ^
/reincarnation/decompiler/flow/SwitchExpressionTest.java:27: ƒGƒ‰[: caseAdefault‚Ü‚½‚Í'}'‚ª‚ ‚è‚Ü‚¹‚ñ
                default -> int local2 = paramlocal2;
                                      ^
/reincarnation/decompiler/flow/SwitchExpressionTest.java:27: ƒGƒ‰[: caseAdefault‚Ü‚½‚Í'}'‚ª‚ ‚è‚Ü‚¹‚ñ
                default -> int local2 = paramlocal2;
                                        ^
/reincarnation/decompiler/flow/SwitchExpressionTest.java:27: ƒGƒ‰[: caseAdefault‚Ü‚½‚Í'}'‚ª‚ ‚è‚Ü‚¹‚ñ
                default -> int local2 = paramlocal2;
                                                   ^

Cannot invoke "java.lang.Class.getDeclaredConstructors()" because "clazz" is null
NullPointerException: Cannot invoke "java.lang.Class.getDeclaredConstructors()" because "clazz" is null
    at reincarnation.CodeVerifier$JavaVerifier.<init>(CodeVerifier.java:379)
    at reincarnation.CodeVerifier.verify(CodeVerifier.java:182)
    at reincarnation.decompiler.flow.SwitchExpressionTest.tryCatch(SwitchExpressionTest.java:242)

============================================================
Original Code
============================================================
@Debuggable
    void tryCatch() {
        verify(new TestCode.IntParam() {

            @Override
            public int run(@Param(from = 0, to = 5) int param) {
                return switch (param) {
                case 0, 1, 2 -> {
                    try {
                        param = MaybeThrow.error(param);
                    } catch (Error e) {
                        param = param + 1;
                    }
                    yield param;
                }
                default -> param;
                };
            }
        });
    }
============================================================
Decompiled Code
============================================================
01    package reincarnation.decompiler.flow;
02    
03    import reincarnation.CodeVerifier;
04    import reincarnation.TestCode.IntParam;
05    import reincarnation.TestCode.Param;
06    import reincarnation.decompiler.flow.MaybeThrow;
07    import reincarnation.decompiler.flow.SwitchExpressionTest;
08    
09    class SwitchExpressionTest extends CodeVerifier {
10    
11        class SwitchExpressionTest$13 implements IntParam {
12    
13            SwitchExpressionTest$13(final SwitchExpressionTest this$0) {
14            }
15    
16            public int run(@Param(to = 5) int param) {
17                return switch (param) {
18                    case 0, 1, 2 -> {
19                        try {
20                            param = MaybeThrow.error(param);
21                        } catch(Error e) {
22                            param += 1;
23                        }
24                        int local2 = param;
25                        yield local2;
26                    }
27                    default -> int local2 = paramlocal2;
28                };
29            }
30        }
31    }
============================================================
Decompiling Log
============================================================
//----------------------------- SwitchExpressionTest#tryCatch (SwitchExpressionTest.java:241) -----------------------------//
[38;5;21mMethod tryCatch()[0m (SwitchExpressionTest.java:242)
0	in[]	out[]	dom[]	doms[]	side[ ,1]	dest[T]	code: java.lang.Object() [ConstructorCall] return null [Return - null]
1	in[]	out[]	dom[]	doms[]	side[0, ]	dest[]	code: 

Delete tail empty return (show full nodes)
[38;5;9m0	in[]	out[]	dom[]	doms[]	side[ , ]	dest[T]	code: java.lang.Object() [ConstructorCall] return null [Return - null]
[0m
[38;5;78m0	in[]	out[]	dom[]	doms[]	side[ , ]	dest[T]	code: java.lang.Object() [ConstructorCall]
[0m

Merge 0 0   []  []
0	in[]	out[]	dom[]	doms[]	side[ , ]	dest[T]	code: java.lang.Object() [ConstructorCall]

//----------------------------- SwitchExpressionTest#tryCatch (SwitchExpressionTest.java:245) -----------------------------//
[38;5;21mMethod tryCatch()[0m (SwitchExpressionTest.java:246)
3	in[]	out[4,0]	dom[]	doms[]	side[ ,0]	dest[0]	try:   	code: switch-expression (arg0) [Switch]
0	in[3]	out[1]		dom[3]	doms[]	side[3,1]	dest[1]	try: s	code: arg0 = MaybeThrow.error(arg0) [Assign#int]
1	in[0]	out[5]		dom[0]	doms[]	side[0,2]	dest[5]	try: e	code: 
2	in[]	out[6]		dom[]	doms[]	side[1,6]	dest[6]	try: c	code: 
6	in[2]	out[5]		dom[2]	doms[]	side[2,5]	dest[5]	try:   	code: arg0 = arg0 + 1 [Assign#int]
5	in[1,6]	out[7]		dom[]	doms[]	side[6,4]	dest[7]	try:   	code: local2 = arg0 [Assign#int] local2 [LocalVariable#int]
4	in[3]	out[7]		dom[3]	doms[]	side[5,7]	dest[7]	try:   	code: local2 = arg0 [Assign#int] local2 [LocalVariable#int]

Analyze switch [Range 3 - 4] (show full nodes)
[38;5;9m3	in[]	out[4,0]	dom[]	doms[0,4]	side[ ,0]	dest[0]	try:   	code: switch-expression (arg0) [Switch]
0	in[3]	out[1]		dom[3]	doms[1,2,5]	side[3,1]	dest[1]	try: s	code: arg0 = MaybeThrow.error(arg0) [Assign#int]
1	in[0]	out[5]		dom[0]	doms[]		side[0,2]	dest[5]	try: e	code: 
2	in[]	out[6]		dom[]	doms[6]		side[1,6]	dest[6]	try: c	code: 
6	in[2]	out[5]		dom[2]	doms[]		side[2,5]	dest[5]	try:   	code: arg0 = arg0 + 1 [Assign#int]
5	in[1,6]	out[7]		dom[]	doms[]		side[6,4]	dest[7]	try:   	code: local2 = arg0 [Assign#int] local2 [LocalVariable#int]
4	in[3]	out[7]		dom[3]	doms[]		side[5,7]	dest[7]	try:   	code: local2 = arg0 [Assign#int] local2 [LocalVariable#int]
[0m
[38;5;78m3	in[]	out[4,0]	dom[]	doms[0,4]	side[ ,0]	dest[0]	try:   	code: switch-expression (arg0) [Switch#int]
0	in[3]	out[1]		dom[3]	doms[1,2,5]	side[3,1]	dest[1]	try: s	code: arg0 = MaybeThrow.error(arg0) [Assign#int]
1	in[0]	out[5]		dom[0]	doms[]		side[0,2]	dest[5]	try: e	code: 
2	in[]	out[6]		dom[]	doms[6]		side[1,6]	dest[6]	try: c	code: 
6	in[2]	out[5]		dom[2]	doms[]		side[2,5]	dest[5]	try:   	code: arg0 = arg0 + 1 [Assign#int]
5	in[1,6]	out[]		dom[]	doms[]		side[6,4]	dest[7]	try:   	code: local2 = arg0 [Assign#int] yield local2 [Yield#int - local2]
4	in[3]	out[]		dom[3]	doms[]		side[5,7]	dest[7]	try:   	code: local2 = arg0 [Assign#int] yield local2 [Yield#int - local2]
[0m

Analyze try-catch-finally (show full nodes)
[38;5;9m3	in[]	out[4,0]	dom[]	doms[0,4]	side[ ,0]	dest[0]	try:   	code: switch-expression (arg0) [Switch#int]
0	in[3]	out[1]		dom[3]	doms[1,2,5]	side[3,1]	dest[1]	try: s	code: arg0 = MaybeThrow.error(arg0) [Assign#int]
1	in[0]	out[5]		dom[0]	doms[]		side[0,2]	dest[5]	try: e	code: 
2	in[]	out[6]		dom[]	doms[6]		side[1,6]	dest[6]	try: c	code: 
6	in[2]	out[5]		dom[2]	doms[]		side[2,5]	dest[5]	try:   	code: arg0 = arg0 + 1 [Assign#int]
5	in[1,6]	out[]		dom[]	doms[]		side[6,4]	dest[7]	try:   	code: local2 = arg0 [Assign#int] yield local2 [Yield#int - local2]
4	in[3]	out[]		dom[3]	doms[]		side[5,7]	dest[7]	try:   	code: local2 = arg0 [Assign#int] yield local2 [Yield#int - local2]
[0m
[38;5;78m3	in[]	out[4,0]	dom[]	doms[0,4]	side[ ,0]	dest[0]	try:   	code: switch-expression (arg0) [Switch#int]
0	in[3]	out[1]		dom[3]	doms[1,2,5]	side[3,1]	dest[1]	try: s	code: arg0 = MaybeThrow.error(arg0) [Assign#int]
1	in[0]	out[5]		dom[0]	doms[]		side[0,2]	dest[5]	try: e	code: 
2	in[]	out[6]		dom[]	doms[6]		side[1,6]	dest[6]	try: c	code: 
6	in[2]	out[5]		dom[2]	doms[]		side[2,5]	dest[5]	try:   	code: arg0 = arg0 + 1 [Assign#int]
5	in[1,6]	out[]		dom[]	doms[]		side[6,4]	dest[7]	try: x	code: local2 = arg0 [Assign#int] yield local2 [Yield#int - local2]
4	in[3]	out[]		dom[3]	doms[]		side[5,7]	dest[7]	try:   	code: local2 = arg0 [Assign#int] yield local2 [Yield#int - local2]
[0m

Merge 0 3   []  [4, 0]
Merge 0 0   [1]  [1]
Merge 1 0
Merge 0 1   []  [5]
Merge 0 2   [6]  [6]
Merge 1 2
Merge 0 6   []  [5]
Merge 0 5   []  []
Merge 0 4   []  []
Build shorthand assign (show full nodes)
[38;5;9m3	in[]	out[4,0]	dom[]	doms[0,4]	side[ ,0]	dest[0]	try:   	code: switch-expression (arg0) [Switch#int]
0	in[3]	out[1]		dom[3]	doms[1,2,5]	side[3,1]	dest[1]	try: s	code: arg0 = MaybeThrow.error(arg0) [Assign#int]
1	in[0]	out[5]		dom[0]	doms[]		side[0,2]	dest[5]	try: e	code: 
2	in[]	out[6]		dom[]	doms[6]		side[1,6]	dest[6]	try: c	code: 
6	in[2]	out[5]		dom[2]	doms[]		side[2,5]	dest[5]	try:   	code: arg0 = arg0 + 1 [Assign#int]
5	in[1,6]	out[]		dom[]	doms[]		side[6,4]	dest[7]	try: x	code: local2 = arg0 [Assign#int] yield local2 [Yield#int - local2]
4	in[3]	out[]		dom[3]	doms[]		side[5,7]	dest[7]	try:   	code: local2 = arg0 [Assign#int] yield local2 [Yield#int - local2]
[0m
[38;5;78m3	in[]	out[4,0]	dom[]	doms[0,4]	side[ ,0]	dest[0]	try:   	code: switch-expression (arg0) [Switch#int]
0	in[3]	out[1]		dom[3]	doms[1,2,5]	side[3,1]	dest[1]	try: s	code: arg0 = MaybeThrow.error(arg0) [Assign#int]
1	in[0]	out[5]		dom[0]	doms[]		side[0,2]	dest[5]	try: e	code: 
2	in[]	out[6]		dom[]	doms[6]		side[1,6]	dest[6]	try: c	code: 
6	in[2]	out[5]		dom[2]	doms[]		side[2,5]	dest[5]	try:   	code: arg0 += 1 [Assign#int]
5	in[1,6]	out[]		dom[]	doms[]		side[6,4]	dest[7]	try: x	code: local2 = arg0 [Assign#int] yield local2 [Yield#int - local2]
4	in[3]	out[]		dom[3]	doms[]		side[5,7]	dest[7]	try:   	code: local2 = arg0 [Assign#int] yield local2 [Yield#int - local2]
[0m

3	in[]	out[4,0]	dom[]	doms[0,4]	side[ ,0]	dest[0]	try:   	code: switch-expression (arg0) [Switch#int]
0	in[3]	out[1]		dom[3]	doms[1,2,5]	side[3,1]	dest[1]	try: s	code: arg0 = MaybeThrow.error(arg0) [Assign#int]
1	in[0]	out[5]		dom[0]	doms[]		side[0,2]	dest[5]	try: e	code: 
2	in[]	out[6]		dom[]	doms[6]		side[1,6]	dest[6]	try: c	code: 
6	in[2]	out[5]		dom[2]	doms[]		side[2,5]	dest[5]	try:   	code: arg0 += 1 [Assign#int]
5	in[1,6]	out[]		dom[]	doms[]		side[6,4]	dest[7]	try: x	code: local2 = arg0 [Assign#int] yield local2 [Yield#int - local2]
4	in[3]	out[]		dom[3]	doms[]		side[5,7]	dest[7]	try:   	code: local2 = arg0 [Assign#int] yield local2 [Yield#int - local2]

Transform switch expression [Range 3 - 4] (show full nodes)
[38;5;9m3	in[]	out[4,0]	dom[]	doms[]	side[ ,0]	dest[0]	try:   	code: switch (arg0) [Switch]
0	in[3]	out[1]		dom[3]	doms[]	side[3,1]	dest[1]	try: s	code: arg0 = MaybeThrow.error(arg0) [Assign#int]
1	in[0]	out[5]		dom[0]	doms[]	side[0,2]	dest[5]	try: e	code: 
2	in[]	out[6]		dom[]	doms[]	side[1,6]	dest[6]	try: c	code: 
6	in[2]	out[5]		dom[2]	doms[]	side[2,5]	dest[5]	try:   	code: arg0 = arg0 + 1 [Assign#int]
5	in[1,6]	out[7]		dom[]	doms[]	side[6,4]	dest[7]	try:   	code: local2 = arg0 [Assign#int] local2 [LocalVariable#int]
4	in[3]	out[7]		dom[3]	doms[]	side[5,7]	dest[7]	try:   	code: local2 = arg0 [Assign#int] local2 [LocalVariable#int]
7	in[5,4]	out[]		dom[]	doms[]	side[4, ]	dest[]	try:   	code: 
[0m
[38;5;78m3	in[]	out[7]	dom[]	doms[]	side[ ,7]	dest[0]	code: switch-expression (arg0) [Switch#int]
7	in[3]	out[]	dom[3]	doms[]	side[3, ]	dest[]	code: 
[0m

[38;5;21mMethod tryCatch()[0m (SwitchExpressionTest.java:246)
3	in[]	out[7]	dom[]	doms[]	side[ ,7]	dest[0]	code: 
7	in[3]	out[]	dom[3]	doms[]	side[3,8]	dest[T]	code: return switch-expression (param) [Return#int - Switch#int]
8	in[]	out[]	dom[]	doms[]	side[7, ]	dest[]	code: 

Merge 0 7   []  []
7	in[]	out[]	dom[]	doms[]	side[ , ]	dest[T]	code: return switch-expression (param) [Return#int - Switch#int]


============================================================
Bytecode Diff -  reincarnation.decompiler.flow.SwitchExpressionTest$13
============================================================
ECJ																		Javac
visitMethod(ACC_PUBLIC, "run", "(I)I", null, null);						visitMethod(ACC_PUBLIC, "run", "(I)I", null, null);
AnnotableParameterCount(1, true);										AnnotableParameterCount(1, true);
TryCatchBlock(L0, L1, L2, "j.l.Error");									TryCatchBlock(L0, L1, L2, "j.l.Error");
Label(L3);																Label(L3);
VarInsn(ILOAD, 1);														VarInsn(ILOAD, 1);
TableSwitchInsn(0, 2, L4, new Label[] { L0, L0, L0 });					TableSwitchInsn(0, 2, L4, new Label[] { L0, L0, L0 });
Label(L0);																Label(L0);
Frame(F_SAME, 0, null, 0, null);										Frame(F_SAME, 0, null, 0, null);
VarInsn(ILOAD, 1);														VarInsn(ILOAD, 1);
MethodInsn(INVOKESTATIC, "MaybeThrow", "error", "(I)I", false);			MethodInsn(INVOKESTATIC, "MaybeThrow", "error", "(I)I", false);
VarInsn(ISTORE, 1);														VarInsn(ISTORE, 1);
Label(L1);																Label(L1);
JumpInsn(GOTO, L5);														JumpInsn(GOTO, L5);
Label(L2);																Label(L2);
Frame(F_SAME1, 0, null, 1, new Object[] {"j.l.Error"});					Frame(F_SAME1, 0, null, 1, new Object[] {"j.l.Error"});
VarInsn(ASTORE, 3);														VarInsn(ASTORE, 3);
Label(L6);																Label(L6);
~IincInsn~(~1~, 1);														+VarInsn+(+ILOAD+, 1);
																		+Insn(ICONST_1);+
																		+Insn(IADD);+
																		+VarInsn(ISTORE, 1);+
Label(L5);																Label(L5);
Frame(F_SAME, 0, null, 0, null);										Frame(F_SAME, 0, null, 0, null);
VarInsn(ILOAD, 1);														VarInsn(ILOAD, 1);
VarInsn(ISTORE, 2);														VarInsn(ISTORE, 2);
~Label(L7);~															
VarInsn(ILOAD, 2);														VarInsn(ILOAD, 2);
~Label~(~L8~);															+JumpInsn+(+GOTO, L7+);
~JumpInsn(GOTO, L9);~													
Label(L4);																Label(L4);
Frame(F_SAME, 0, null, 0, null);										Frame(F_SAME, 0, null, 0, null);
VarInsn(ILOAD, 1);														VarInsn(ILOAD, 1);
VarInsn(ISTORE, 2);														VarInsn(ISTORE, 2);
~Label(L10);~															
VarInsn(ILOAD, 2);														VarInsn(ILOAD, 2);
Label(~L9~);															Label(+L7+);
Frame(F_SAME1, 0, null, 1, new Object[] {INTEGER});						Frame(F_SAME1, 0, null, 1, new Object[] {INTEGER});
Insn(IRETURN);															Insn(IRETURN);
Label(~L11~);															Label(+L8+);
~LocalVariable("this", "LSwitchExpressionTest$13;", null, L3, L11, 0);~	
~LocalVariable("param", "I", null, L3, L11, 1);~						
LocalVariable("e", "Lj.l.Error;", null, L6, L5, 3);						LocalVariable("e", "Lj.l.Error;", null, L6, L5, 3);
LocalVariable(~" secretYieldValue"~, ~"I"~, null, ~L7~, L8, ~2~);		LocalVariable(+"this"+, +"LSwitchExpressionTest$13;"+, null, +L3+, L8, +0+);
LocalVariable(~" secretYieldValue"~, "I", null, ~L10~, ~L9~, ~2~);		LocalVariable(+"param"+, "I", null, +L3+, +L8+, +1+);
============================================================
Bytecode Diff -  reincarnation.decompiler.flow.SwitchExpressionTest$13
============================================================
ECJ																		Javac
visitMethod(ACC_PUBLIC, "run", "(I)I", null, null);						visitMethod(ACC_PUBLIC, "run", "(I)I", null, null);
AnnotableParameterCount(1, true);										AnnotableParameterCount(1, true);
TryCatchBlock(L0, L1, L2, "j.l.Error");									TryCatchBlock(L0, L1, L2, "j.l.Error");
Label(L3);																Label(L3);
VarInsn(ILOAD, 1);														VarInsn(ILOAD, 1);
TableSwitchInsn(0, 2, L4, new Label[] { L0, L0, L0 });					TableSwitchInsn(0, 2, L4, new Label[] { L0, L0, L0 });
Label(L0);																Label(L0);
Frame(F_SAME, 0, null, 0, null);										Frame(F_SAME, 0, null, 0, null);
VarInsn(ILOAD, 1);														VarInsn(ILOAD, 1);
MethodInsn(INVOKESTATIC, "MaybeThrow", "error", "(I)I", false);			MethodInsn(INVOKESTATIC, "MaybeThrow", "error", "(I)I", false);
VarInsn(ISTORE, 1);														VarInsn(ISTORE, 1);
Label(L1);																Label(L1);
JumpInsn(GOTO, L5);														JumpInsn(GOTO, L5);
Label(L2);																Label(L2);
Frame(F_SAME1, 0, null, 1, new Object[] {"j.l.Error"});					Frame(F_SAME1, 0, null, 1, new Object[] {"j.l.Error"});
VarInsn(ASTORE, 3);														VarInsn(ASTORE, 3);
Label(L6);																Label(L6);
~IincInsn~(~1~, 1);														+VarInsn+(+ILOAD+, 1);
																		+Insn(ICONST_1);+
																		+Insn(IADD);+
																		+VarInsn(ISTORE, 1);+
Label(L5);																Label(L5);
Frame(F_SAME, 0, null, 0, null);										Frame(F_SAME, 0, null, 0, null);
VarInsn(ILOAD, 1);														VarInsn(ILOAD, 1);
VarInsn(ISTORE, 2);														VarInsn(ISTORE, 2);
~Label(L7);~															
VarInsn(ILOAD, 2);														VarInsn(ILOAD, 2);
~Label~(~L8~);															+JumpInsn+(+GOTO, L7+);
~JumpInsn(GOTO, L9);~													
Label(L4);																Label(L4);
Frame(F_SAME, 0, null, 0, null);										Frame(F_SAME, 0, null, 0, null);
VarInsn(ILOAD, 1);														VarInsn(ILOAD, 1);
VarInsn(ISTORE, 2);														VarInsn(ISTORE, 2);
~Label(L10);~															
VarInsn(ILOAD, 2);														VarInsn(ILOAD, 2);
Label(~L9~);															Label(+L7+);
Frame(F_SAME1, 0, null, 1, new Object[] {INTEGER});						Frame(F_SAME1, 0, null, 1, new Object[] {INTEGER});
Insn(IRETURN);															Insn(IRETURN);
Label(~L11~);															Label(+L8+);
~LocalVariable("this", "LSwitchExpressionTest$13;", null, L3, L11, 0);~	
~LocalVariable("param", "I", null, L3, L11, 1);~						
LocalVariable("e", "Lj.l.Error;", null, L6, L5, 3);						LocalVariable("e", "Lj.l.Error;", null, L6, L5, 3);
LocalVariable(~" secretYieldValue"~, ~"I"~, null, ~L7~, L8, ~2~);		LocalVariable(+"this"+, +"LSwitchExpressionTest$13;"+, null, +L3+, L8, +0+);
LocalVariable(~" secretYieldValue"~, "I", null, ~L10~, ~L9~, ~2~);		LocalVariable(+"param"+, "I", null, +L3+, +L8+, +1+);
============================================================

WARNING: A Java agent has been loaded dynamically (C:\Users\minam\AppData\Local\Temp\antibug1918019657505839673agent.jar)
WARNING: If a serviceability tool is in use, please run with -XX:+EnableDynamicAgentLoading to hide this warning
WARNING: If a serviceability tool is not in use, please run with -Djdk.instrument.traceUsage for more information
WARNING: Dynamic loading of agents will be disallowed by default in a future release
